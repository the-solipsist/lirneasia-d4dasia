/**
 * MANAGE PANDOC ATTRIBUTES
 * ========================
 * 
 * Usage:
 *   quarto run _scripts/manage_element_attributes.ts
 *   quarto run _scripts/manage_element_attributes.ts -- --fix
 * 
 * Description:
 *   This script interfaces with Pandoc to manage HTML/Div/Span attributes.
 *   It serves two distinct purposes based on the mode:
 * 
 *   1. Audit Mode (Default): 
 *      Uses `audit-div-span-attributes.lua` to scan the document structure
 *      and report on:
 *        - Missing Alt Text on images.
 *        - Broken highlighting syntax (e.g. `.mark` in spans).
 *        - Unwanted inline styles (e.g. `style=`, `width=`).
 * 
 *   2. Fix Mode (--fix):
 *      Uses `remove-div-span-attributes.lua` to rewriting the file,
 *      automatically stripping specific unwanted attributes like:
 *        - Hardcoded Header IDs (unless needed).
 *        - Target classes (e.g., .email, .uri auto-generated by Pandoc).
 */

// --- IMPORTS ---
import { walk } from "stdlib/fs";
import { join, dirname, fromFileUrl, relative } from "stdlib/path";
import { parse } from "stdlib/flags";

// --- CONFIGURATION ---
const scriptDir = dirname(fromFileUrl(import.meta.url));
const reportsDir = join(scriptDir, "../reports");

// Lua Filters
const LUA_AUDIT = join(scriptDir, "manage_element_attributes.audit.lua");
const LUA_REMOVE = join(scriptDir, "manage_element_attributes.remove.lua");

// --- ARGUMENT PARSING ---
const args = parse(Deno.args, {
  boolean: ["fix"],
  alias: { fix: ["execute", "e"] },
});
const isFixMode = args.fix;

// --- CATEGORIES (For Audit Reporting) ---
type Category = "MARK" | "ALT_FAIL" | "STYLE" | "REF" | "OTHER";


// --- MAIN EXECUTION ---

// Verify Lua filters exist
try {
  await Deno.stat(LUA_AUDIT);
  await Deno.stat(LUA_REMOVE);
} catch (e) {
  console.error("‚ùå Critical Error: Lua filters missing in _scripts/.");
  Deno.exit(1);
}

console.log("-".repeat(60));
if (isFixMode) {
  console.log("‚ö†Ô∏è  FIX MODE: Stripping unwanted attributes (Rewriting files)...");
} else {
  console.log("üîç AUDIT MODE: Scanning for attribute issues...");
  console.log("   Legend: üö® Critical (Alt Text/Broken) | üü† Style/Cleanup | üìò Info");
}
console.log("-".repeat(60));


// Start the file walk
let filesProcessed = 0;
for await (const entry of walk(reportsDir)) {
  if (entry.isFile && entry.name.endsWith(".qmd")) {
    
    // Skip common/ folder for audit noise reduction? 
    // No, common files should be audited too.
    
    if (isFixMode) {
      await runFixer(entry.path);
    } else {
      await runAuditor(entry.path);
    }
    filesProcessed++;
  }
}

console.log("-".repeat(60));
console.log(`Processed ${filesProcessed} files.`);
if (!isFixMode) {
  console.log("To strip unwanted attributes, run with \x1b[1m--fix\x1b[0m.");
}


// --- FUNCTIONS ---

/**
 * AUDIT MODE: Runs Pandoc with the auditing Lua filter.
 * Captures stderr (where the Lua filter logs) and parses it into a report.
 */
async function runAuditor(filePath: string) {
  const relPath = relative(join(scriptDir, ".."), filePath);

  const cmd = new Deno.Command("quarto", {
    args: ["pandoc", filePath, "--from", "markdown", "--lua-filter", LUA_AUDIT, "--to", "native"],
    stdout: "null", 
    stderr: "piped",
  });

  const { stderr } = await cmd.output();
  const rawOutput = new TextDecoder().decode(stderr).trim();

  if (!rawOutput) return;

  const buckets: Record<Category, string[]> = { MARK: [], ALT_FAIL: [], STYLE: [], REF: [], OTHER: [] };
  let hasItems = false;

  rawOutput.split("\n").forEach(line => {
    const parts = line.split("|");
    if (parts.length >= 4) {
      const [_, type, attrs, content] = parts;
      
      // Extract ID for classification
      const idMatch = attrs.match(/#([\w-]+)/);
      const id = idMatch ? idMatch[1] : "";

      const cat = classifyAudit(attrs, type, id);
      const icon = getIcon(cat);
      
      const display = `   ${icon} [${type}] ${attrs} \x1b[2m"${content}"\x1b[0m`;
      buckets[cat].push(display);
      hasItems = true;
    }
  });

  if (hasItems) {
    console.log(`\x1b[1müìÑ ${relPath}\x1b[0m`);
    printBucket("Highlights & Missing Alt", [...buckets.ALT_FAIL, ...buckets.MARK]);
    printBucket("Styling", buckets.STYLE);
    printBucket("Figures & Tables", buckets.REF);
    printBucket("Other", buckets.OTHER);
    console.log(""); 
  }
}

/**
 * FIX MODE: Runs Pandoc with the removal Lua filter.
 * Rewrites the file in place.
 */
async function runFixer(filePath: string) {
  const relPath = relative(join(scriptDir, ".."), filePath);
  
  // Pandoc command to rewrite the file
  const cmd = new Deno.Command("quarto", {
    args: [
      "pandoc", filePath,
      "--from", "markdown",
      "--lua-filter", LUA_REMOVE,
      "--to", "markdown",
      "--output", filePath, // Overwrite
      "--wrap=none"         // Preserve wrapping style
    ],
    stdout: "inherit",
    stderr: "piped",
  });

  const { stderr, success } = await cmd.output();
  const output = new TextDecoder().decode(stderr).trim();

  if (!success) {
    console.error(`‚ùå Error processing ${relPath}`);
    console.error(output);
    return;
  }

  // Parse logs from Lua to see what changed
  let printedHeader = false;
  output.split("\n").forEach(line => {
    if (line.startsWith("CHANGE|")) {
      if (!printedHeader) {
        console.log(`\x1b[1müìÑ ${relPath}\x1b[0m`);
        printedHeader = true;
      }
      
      const parts = line.split("|");
      if (parts.length >= 5) {
         const type = parts[2];
         const before = parts[3];
         const after = parts[4];
         console.log(`   \x1b[36m[${type}]\x1b[0m ${before} -> ${after}`);
      }
    }
  });
  if (printedHeader) console.log("");
}


// --- HELPERS ---

function classifyAudit(attrs: string, type: string, id: string): Category {
  const a = attrs.toLowerCase();
  if (type === "Image (No Alt)") return "ALT_FAIL";
  if (a.includes(".mark") || type === "Text (Raw)" || a.includes("comment") || a.includes("background-color")) return "MARK";
  if (a.includes(".underline") || a.includes("style=") || a.includes("width=") || a.includes("color")) return "STYLE";
  if (id.startsWith("tbl-") || id.startsWith("fig-")) return "REF";
  return "OTHER";
}

function getIcon(cat: Category): string {
  if (cat === "MARK" || cat === "ALT_FAIL") return "\x1b[31müö®\x1b[0m"; // Red
  if (cat === "STYLE") return "\x1b[33müü†\x1b[0m"; // Yellow
  if (cat === "REF")   return "\x1b[34müìò\x1b[0m"; // Blue
  return "‚ö™";
}

function printBucket(title: string, items: string[]) {
  if (items.length > 0) {
    console.log(`   \x1b[4m${title}\x1b[0m`);
    items.forEach(i => console.log(i));
  }
}
